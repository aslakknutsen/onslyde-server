package com.onslyde.websockets;

import com.onslyde.model.Mediator;
import com.onslyde.model.SlidFast;
import com.onslyde.util.ClientEvent;
import org.eclipse.jetty.io.Connection;
import org.eclipse.jetty.util.ConcurrentHashSet;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.WebSocketListener;
import org.eclipse.jetty.websocket.api.annotations.*;
import org.eclipse.jetty.websocket.server.WebSocketServerConnection;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.inject.Inject;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.logging.Logger;


@WebSocket
public class LogSocket {

    @Inject
    private static SlidFast slidFast;

    @Inject
    private static Mediator mediator;

    @Inject
    private Logger log;

    private Session session;
    private Connection connection;
    private String ACTIVE_OPTIONS = "activeOptions:";
    private String REMOTE_MARKUP = "remoteMarkup";
    private String ROULETTE = "roulette";
    private String VOTE = "vote:";
    private String SEPARATOR = ":";

    String attendeeIP = "111.111.111.111";
    int sessionID = 0;


    public void observeItemEvent(@Observes Mediator mediator) {
        syncMediator(mediator);
//        System.out.println("-slidFast.getJsEvent()-------" + mediator.getJsEvent());
        if (mediator.getJsEvent() != null) {
            try {

                for (LogSocket sock : mediator.getWebsockets()) {
                    sock.session.getRemote().sendStringByFuture(mediator.getJsEvent());
                }


            } catch (Exception x) {
                //todo - do something
                x.printStackTrace();
            }
        }
    }

    private int getAttendeeID() {
        return 0;
    }

    private int wscount = 0;

    @OnWebSocketConnect
    public void onOpen(Session session) {

        this.session = session;

        session.setIdleTimeout(1000000);
        Map request = session.getUpgradeRequest().getParameterMap();



        if (request.get("attendeeIP") != null)
            attendeeIP = ((String[]) request.get("attendeeIP"))[0];



        if (request.get("session") != null)
            sessionID = Integer.parseInt(((String[]) request.get("session"))[0]);

        System.out.println("-----------" + mediator);
        System.out.println("-----------" + mediator.getSessions());


        System.err.printf("onWebSocketConnect(%s)%n", session);


        //when a user connects, we add his ws connection to a sessionID map
        if (mediator.getSessions().containsKey(sessionID)) {
            mediator.getSessions().get(sessionID).add(this);
        } else {
            ConcurrentLinkedQueue<LogSocket> newList = new ConcurrentLinkedQueue<LogSocket>();
            newList.add(this);
            mediator.getSessions().put(sessionID, newList);
        }


        //-----begin old onopen

        // Client (Browser) WebSockets has opened a connection.
        // 1) Store the opened connection
        // 2) Add ChatWebSocket in the global list of ChatWebSocket


        mediator.getWebsockets().add(this);
        int pollCount = 0;
        //send current state to remotes

        try {
//                System.out.println("mediator: " + mediator);
            if (mediator != null) {
                if (mediator.getPollCount().containsKey(sessionID)) {
                    pollCount = mediator.getPollCount().get(sessionID);
                }
                System.out.println("_____sessions in map: " + mediator.getSessionID() + " users session: " + sessionID + " size for session: " + mediator.getSessions().get(sessionID).size());
                if (mediator.getActiveOptions().containsKey(sessionID)) {
                    Mediator.SessionTracker st = mediator.getActiveOptions().get(sessionID);

                    List options = st.getActiveOptions();
                    if (options.size() == 3) {

                        System.out.println("options sent to new remote: " + options + " users session:" + sessionID +  " : " + this.session + "   " + ClientEvent.createEvent("updateOptions", options, sessionID));
                        //only send options to this connection

                        this.session.getRemote().sendStringByFuture(ClientEvent.createEvent("updateOptions", options, sessionID));

                    }
                }
            }
        } catch (Exception e) {
            System.out.println("error1=========");
            e.printStackTrace();
        }
        //update count on deck
        try {
            if (getSlidFast() != null) {

//                    wscount++;
                //                //System.out.println("connect" + wscount);
//                    slidFast.setWscount(wscount);
                //todo - very inefficient... this only needs to go to presenter/slide deck
                if (mediator.getSessions().containsKey(sessionID)) {
                    ConcurrentLinkedQueue<LogSocket> channelSessions = mediator.getSessions().get(sessionID);
                    int wscount = channelSessions.size();
                    System.out.println("========2" + ClientEvent.updateCount(wscount, pollCount, sessionID) + " : " + this.session);
                    this.session.getRemote().sendStringByFuture(ClientEvent.updateCount(wscount, pollCount, sessionID));

                }

            }

        } catch (Exception e) {
            System.out.println("error2=========");
            e.printStackTrace();
        }


    }

    @OnWebSocketMessage
    public void onText(String data) {

            System.err.printf("onWebSocketText(%s)%n", quote(data));


        //dont do anything if the presenter has not started the session
        //todo inform the remote
//            if(sessions.containsKey(sessionID)){

//            System.out.println("------data-" + data + " sessionID" + sessionID);
        //btw, switch on string coming in JDK 7...quicker to use if/else if for now
        if (data.equals("nextSlide")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObja = document.createEvent('Event');" +
                    "eventObja.initEvent(\'slideEvent\', true, true);" +
                    "eventObja.action = 'next';\n" +
                    "document.dispatchEvent(eventObja);" +
                    "}}}");
        } else if (data.equals("previousSlide")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObj1 = document.createEvent('Event');" +
                    "eventObj1.initEvent(\'slideEvent\', true, true);" +
                    "eventObj1.action = 'previous';\n" +
                    "document.dispatchEvent(eventObj1);" +
                    "}}}");
        } else if (data.equals("clearRoute")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObj2 = document.createEvent('Event');" +
                    "eventObj2.initEvent(\'clearRoute\', true, true);" +
                    "document.dispatchEvent(eventObj2);" +
                    "}}}");
        } else if (data.equals("vote:wtf")) {
            data = ("{\"onslydeEvent\":{\"sessionID\":\"" + sessionID + "\"," +
                    "\"fire\":function(){" +
                    "window.eventObj3 = document.createEvent('Event');" +
                    "eventObj3.initEvent(\'wtf\', true, true);" +
                    "document.dispatchEvent(eventObj3);" +
                    "}}}");
            try {
                //System.out.println("wtf))))) " + attendeeIP);
                getSlidFast().updateGroupVote("wtf", attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            sendToPresenter(data, this.session, sessionID);

        } else if (data.equals("vote:nice")) {
            data = ("{\"onslydeEvent\":{\"sessionID\":\"" + sessionID + "\"," +
                    "\"fire\":function(){" +
                    "window.eventObj4 = document.createEvent('Event');" +
                    "eventObj4.initEvent(\'nice\', true, true);" +
                    "document.dispatchEvent(eventObj4);" +
                    "}}}");
            try {
                getSlidFast().updateGroupVote("nice", attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            sendToPresenter(data, this.session, sessionID);

        } else if (data.contains(ACTIVE_OPTIONS)) {
            String options = data.substring(ACTIVE_OPTIONS.length(), data.length());
            List<String> optionList = Arrays.asList(options.split("\\s*,\\s*"));
//                System.out.println("=======optionList.size()=" + optionList.size() + " " + optionList.get(2));
            if (optionList.size() == 3) {
                try {
                    getSlidFast().addGroupOptions(optionList, sessionID);
                } catch (Exception e) {
                    e.printStackTrace();
                }

                data = ClientEvent.createEvent("updateOptions", optionList, sessionID);
                try {
                    sendToAll(data, this.session, sessionID);
                } catch (IOException e) {
                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                }
            }
        } else if (data.contains(VOTE)) {

            String vote = data.substring(VOTE.length(), data.length());

            try {
                getSlidFast().updateGroupVote(vote, attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }

            data = ClientEvent.clientVote(vote, sessionID);
            sendToPresenter(data, this.session, sessionID);

        } else if (data.contains(REMOTE_MARKUP)) {

            data = ClientEvent.remoteMarkup(data, sessionID);
            try {
                getSlidFast().broadcastMarkup(data, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                sendToAll(data, this.session, sessionID);
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
//                //System.out.println("-----------" + data);
        } else if (data.contains(ROULETTE)) {

            data = ClientEvent.roulette(sessionID, false);

            try {
                sendToAll(data, this.session, sessionID);
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }

            List<LogSocket> channelSessions = new ArrayList<LogSocket>();
            //we don't want the presenter socket
            for (LogSocket cws : mediator.getSessions().get(sessionID)) {
                if (cws != mediator.getPsessions().get(sessionID)) {
                    channelSessions.add(cws);
                }
            }

            Random random = new Random();
            LogSocket winner = channelSessions.get(random.nextInt(channelSessions.size()));

            try {
                winner.session.getRemote().sendStringByFuture(ClientEvent.roulette(sessionID, true));
            } catch (Exception e) {
                e.printStackTrace();
            }

//                //System.out.println("-----------" + data);
        } else if (data.contains("::connect::")) {
            try {
//
                //System.out.println("-start session----------" + sessionID);
//                    syncSlidFast(slidFast);
//                    if(slidFast == null){
//                        syncMediator(mediator);
//                    }
                getSlidFast().startSession(sessionID);
                getSlidFast().setPollcount(0);
                if (!mediator.getPsessions().containsKey(sessionID)) {
                    mediator.getPsessions().put(sessionID, this);
                }
                System.out.println("-start session----------" + this + "-------" +  mediator.getPsessions().size());

            } catch (Exception e) {
                e.printStackTrace();
            }
        } else if (data.contains("::disconnect::")) {
            try {
//                    syncSlidFast(slidFast);
                System.out.println("-disconnect session----------" + sessionID);
                for (int i : mediator.getSessionID()) {
                    if (i == sessionID) {
                        System.out.println("-remove----------" + sessionID);
                        mediator.getSessionID().remove(i);
                    }
                }
                if (mediator.getSessions().containsKey(sessionID)) {
                    System.out.println("-sessions.remove----------" + mediator.getSessions().get(sessionID));
                    mediator.getSessions().remove(sessionID);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

//            //System.out.println("-----------" + data);
        //fan out

//            }

    }

    @OnWebSocketClose
    public void onClose(int statusCode, String reason) {
//        BROADCAST.remove(this);
        // Remove ChatWebSocket in the global list of ChatWebSocket
        // instance.
        if(mediator.getSessions().containsKey(sessionID)){
            System.out.println("-remove attendee socket----------" + sessionID);
            mediator.getSessions().get(sessionID).remove(this);
            if(mediator.getSessions().get(sessionID).size() == 0){
                System.out.println("-remove session ID from memory----------" + sessionID);
                mediator.getSessions().remove(sessionID);
                Iterator<Integer> i = mediator.getSessionID().iterator();
                while (i.hasNext()) {
                    Integer s = i.next();
                    i.remove();
                }
            }
        }
        mediator.getWebsockets().remove(this);

    }

    @OnWebSocketError
    public void onWebSocketError(Throwable cause) {

            System.err.printf("onWebSocketError((%s) %s)%n", cause.getClass().getName(), cause.getMessage());
            cause.printStackTrace(System.err);

    }

    private String quote(String str) {
        if (str == null) {
            return "<null>";
        }
        return '"' + str + '"';
    }

    private void sendToAll(String data, Session connection, int sessionID) throws IOException {
        try {
            System.out.println("sendToAll: " + " " + data + " "  + connection + " " + sessionID);
            //only send data to specified sessionID
            ConcurrentLinkedQueue<LogSocket> channelSessions = mediator.getSessions().get(sessionID);
            for (LogSocket webSocket : channelSessions) {
                webSocket.session.getRemote().sendStringByFuture(data);
            }
        } catch (Exception x) {
            // Error was detected, close the ChatWebSocket client side
            try {
                connection.disconnect();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }

        }
    }

    private void sendToPresenter(String data, Session connection, int sessionID) {
        try {

            System.out.println("send to presenter: " + mediator.getPsessions().get(sessionID).session + " --- " + connection);
            if (mediator.getPsessions().containsKey(sessionID)) {
                mediator.getPsessions().get(sessionID).session.getRemote().sendStringByFuture(data);
            }

        } catch (Exception x) {
            // Error was detected, close the ChatWebSocket client side
            try {
                connection.disconnect();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
    }

    public static synchronized void syncMediator(Mediator mediator2) {
        mediator = mediator2;
    }

    public static synchronized Mediator getMediator() {
        return mediator;
    }

    public static synchronized SlidFast getSlidFast() {
        if(slidFast == null){
            syncSlidFast(slidFast);
        }
        return slidFast;// == null ? new SlidFast() : slidFast;
    }

    public static synchronized void syncSlidFast(SlidFast slidFast2) {
        slidFast = slidFast2;
    }

    public void observeItemEvent(@Observes SlidFast slidFast) {
        syncSlidFast(slidFast);
    }


}











package com.onslyde.websockets;

import com.onslyde.model.Mediator;
import com.onslyde.model.SlidFast;
import com.onslyde.util.ClientEvent;
import org.eclipse.jetty.io.Connection;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.WebSocketListener;
import org.eclipse.jetty.websocket.server.WebSocketHandler;
import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.inject.Inject;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.logging.Logger;

@ApplicationScoped
public class OnslydeWebSocketHandler implements WebSocketListener
{
    @Inject
    private static SlidFast slidFast;

    @Inject
    private static Mediator mediator;

    @Inject
    private Logger log;


//    private Session session;
    private Connection connection;
    private String ACTIVE_OPTIONS = "activeOptions:";
    private String REMOTE_MARKUP = "remoteMarkup";
    private String ROULETTE = "roulette";
    private String VOTE = "vote:";
    private String SEPARATOR = ":";

    String attendeeIP = "111.111.111.111";
    int sessionID = 0;

    public void observeItemEvent(@Observes Mediator mediator) {
        syncMediator(mediator);

        if (mediator.getJsEvent() != null) {
            try {

                for (Session session : mediator.getWebsockets()) {
                    session.getRemote().sendStringByFuture(mediator.getJsEvent());
                }


            } catch (Exception x) {
                //todo - do something
                x.printStackTrace();
            }
        }
    }

    @Override
    public void onWebSocketConnect(Session session)
    {
        session.setIdleTimeout(1000000);
        Map request = session.getUpgradeRequest().getParameterMap();

        if (request.get("attendeeIP") != null)
            attendeeIP = ((String[]) request.get("attendeeIP"))[0];

        if (request.get("session") != null)
            sessionID = Integer.parseInt(((String[]) request.get("session"))[0]);

        //when a user connects, we add his ws connection to a sessionID map
        if (mediator.getSessions().containsKey(sessionID)) {
            //get the map and put new value (dropping the old)
            mediator.getSessions().get(sessionID).put(attendeeIP,session);

        } else {
            Map<String,Session> sessionMap = new HashMap<String,Session>();
            sessionMap.put(attendeeIP,session);
            mediator.getSessions().put(sessionID, sessionMap);
        }

        System.out.println("----attendeeIP: " + attendeeIP);

        int pollCount = 0;

        try {
            if (mediator != null) {
                if (mediator.getPollCount().containsKey(sessionID)) {
                    pollCount = mediator.getPollCount().get(sessionID);
                }
                System.out.println("_____sessions in map: " + mediator.getSessionID() + " users session: " + sessionID + " size for session: " + mediator.getSessions().get(sessionID).size());

                if (mediator.getActiveOptions().containsKey(sessionID)) {

                    Mediator.SessionTracker st = mediator.getActiveOptions().get(sessionID);
                    List options = st.getActiveOptions();
                    if (options.size() == 3) {
                        //only send options to this connection
                        session.getRemote().sendStringByFuture(ClientEvent.createEvent("updateOptions", options, sessionID));
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("error1=========");
            e.printStackTrace();
        }
        //update count on deck
        try {
            if (getSlidFast() != null) {

                //todo - very inefficient... this only needs to go to presenter/slide deck
                if (mediator.getSessions().containsKey(sessionID)) {
                    int wscount  = mediator.getSessions().get(sessionID).size();
                    session.getRemote().sendStringByFuture(ClientEvent.updateCount(wscount, pollCount, sessionID));
                }

            }

        } catch (Exception e) {
            System.out.println("error2=========");
            e.printStackTrace();
        }
    }

    @Override
    public void onWebSocketText(Session session, String data)
    {

        System.out.println();

        if (data.equals("nextSlide")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObja = document.createEvent('Event');" +
                    "eventObja.initEvent(\'slideEvent\', true, true);" +
                    "eventObja.action = 'next';\n" +
                    "document.dispatchEvent(eventObja);" +
                    "}}}");
        } else if (data.equals("previousSlide")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObj1 = document.createEvent('Event');" +
                    "eventObj1.initEvent(\'slideEvent\', true, true);" +
                    "eventObj1.action = 'previous';\n" +
                    "document.dispatchEvent(eventObj1);" +
                    "}}}");
        } else if (data.equals("clearRoute")) {
            data = ("{\"cdievent\":{\"fire\":function(){" +
                    "window.eventObj2 = document.createEvent('Event');" +
                    "eventObj2.initEvent(\'clearRoute\', true, true);" +
                    "document.dispatchEvent(eventObj2);" +
                    "}}}");
        } else if (data.equals("vote:wtf")) {
            data = ("{\"onslydeEvent\":{\"sessionID\":\"" + sessionID + "\"," +
                    "\"fire\":function(){" +
                    "window.eventObj3 = document.createEvent('Event');" +
                    "eventObj3.initEvent(\'wtf\', true, true);" +
                    "document.dispatchEvent(eventObj3);" +
                    "}}}");
            try {
                //System.out.println("wtf))))) " + attendeeIP);
                getSlidFast().updateGroupVote("wtf", attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            sendToPresenter(data, this.session, sessionID);

        } else if (data.equals("vote:nice")) {
            data = ("{\"onslydeEvent\":{\"sessionID\":\"" + sessionID + "\"," +
                    "\"fire\":function(){" +
                    "window.eventObj4 = document.createEvent('Event');" +
                    "eventObj4.initEvent(\'nice\', true, true);" +
                    "document.dispatchEvent(eventObj4);" +
                    "}}}");
            try {
                getSlidFast().updateGroupVote("nice", attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            sendToPresenter(data, this.session, sessionID);

        } else if (data.contains(ACTIVE_OPTIONS)) {
            String options = data.substring(ACTIVE_OPTIONS.length(), data.length());
            List<String> optionList = Arrays.asList(options.split("\\s*,\\s*"));
//                System.out.println("=======optionList.size()=" + optionList.size() + " " + optionList.get(2));
            if (optionList.size() == 3) {
                try {
                    getSlidFast().addGroupOptions(optionList, sessionID);
                } catch (Exception e) {
                    e.printStackTrace();
                }

                data = ClientEvent.createEvent("updateOptions", optionList, sessionID);
                try {
                    sendToAll(data, this.session, sessionID);
                } catch (IOException e) {
                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                }
            }
        } else if (data.contains(VOTE)) {

            String vote = data.substring(VOTE.length(), data.length());

            try {
                getSlidFast().updateGroupVote(vote, attendeeIP, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }

            data = ClientEvent.clientVote(vote, sessionID);
            sendToPresenter(data, this.session, sessionID);

        } else if (data.contains(REMOTE_MARKUP)) {

            data = ClientEvent.remoteMarkup(data, sessionID);
            try {
                getSlidFast().broadcastMarkup(data, sessionID);
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                sendToAll(data, this.session, sessionID);
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
//                //System.out.println("-----------" + data);
        } else if (data.contains(ROULETTE)) {

            data = ClientEvent.roulette(sessionID, false);

            try {
                sendToAll(data, this.session, sessionID);
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }

            List<Session> channelSessions = new ArrayList<Session>();
            //we don't want the presenter socket
            for (Session cws : mediator.getSessions().get(sessionID)) {
                if (cws != mediator.getPsessions().get(sessionID)) {
                    channelSessions.add(cws);
                }
            }

            Random random = new Random();
            Session winner = channelSessions.get(random.nextInt(channelSessions.size()));

            try {
                winner.getRemote().sendStringByFuture(ClientEvent.roulette(sessionID, true));
            } catch (Exception e) {
                e.printStackTrace();
            }

        } else if (data.contains("::connect::")) {
            try {

                getSlidFast().startSession(sessionID);
                getSlidFast().setPollcount(0);
                System.out.println("----" + mediator.getPsessions().containsKey(sessionID));
//                if (!mediator.getPsessions().containsKey(sessionID)) {
                    mediator.getPsessions().put(sessionID, this.session);
//                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        } else if (data.contains("::disconnect::")) {
            try {

                for (int i : mediator.getSessionID()) {
                    if (i == sessionID) {
                        mediator.getSessionID().remove(i);
                    }
                }
                if (mediator.getSessions().containsKey(sessionID)) {
                    mediator.getSessions().remove(sessionID);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }


    private void sendToAll(String data, Session connection, int sessionID) throws IOException {
        try {
            //only send data to specified sessionID
            ConcurrentLinkedQueue<Session> channelSessions = mediator.getSessions().get(sessionID);
            for (Session webSocket : channelSessions) {
                webSocket.getRemote().sendStringByFuture(data);
            }
        } catch (Exception x) {
            // Error was detected, close the ChatWebSocket client side
            try {
                connection.disconnect();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }

        }
    }

    private void sendToPresenter(String data, Session connection, int sessionID) {
        try {

            if (mediator.getPsessions().containsKey(sessionID)) {
                mediator.getPsessions().get(sessionID).getRemote().sendStringByFuture(data);
            }

        } catch (Exception x) {
            // Error was detected, close the ChatWebSocket client side
            try {
                connection.disconnect();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void onWebSocketBinary(byte[] bytes, int i, int i1) {

    }

    @Override
    public void onWebSocketClose(int statusCode, String reason)
    {
        if(mediator.getSessions().containsKey(sessionID)){
            System.out.println("-remove attendee socket----------" + sessionID + " sesseio " + this.session);
            mediator.getSessions().get(sessionID).remove(this.session);
            if(mediator.getSessions().get(sessionID).size() == 0){
                System.out.println("-remove session ID from memory----------" + sessionID);
                mediator.getSessions().remove(sessionID);
                Iterator<Integer> i = mediator.getSessionID().iterator();
                while (i.hasNext()) {
                    Integer s = i.next();
                    i.remove();
                }
            }
        }
        mediator.getWebsockets().remove(this.session);
    }

    @Override
    public void onWebSocketError(Throwable cause)
    {
       System.out.println("---WEBSOCKET error: " + cause);
    }

    public static synchronized void syncMediator(Mediator mediator2) {
        mediator = mediator2;
    }

    public static synchronized Mediator getMediator() {
        return mediator;
    }

    public static synchronized SlidFast getSlidFast() {
        if(slidFast == null){
            syncSlidFast(slidFast);
        }
        return slidFast;// == null ? new SlidFast() : slidFast;
    }

    public static synchronized void syncSlidFast(SlidFast slidFast2) {
        slidFast = slidFast2;
    }

    public void observeItemEvent(@Observes SlidFast slidFast) {
        syncSlidFast(slidFast);
    }


}
